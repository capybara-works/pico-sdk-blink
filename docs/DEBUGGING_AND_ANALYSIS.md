# デバッグ・解析ガイド (Debugging and Analysis Guide)

## 1. 概要
本プロジェクトでは、ビルドプロセスに高度な静的解析ツールの実行を統合しており、生成されたバイナリの詳細な検証が可能です。
これにより、デバッガを接続できない環境や、事後的なクラッシュ解析においても、ソースコードレベルでの追跡が可能となっています。

## 2. ソースコード付き逆アセンブル (Source-Interleaved Disassembly)

### 2.1 概要
ビルドプロセス (`cmake --build` または `build_and_test.sh`) の完了後、自動的に以下のファイルが生成されます。

*   **ファイルパス**: `build/blink.S.dis`
*   **生成ツール**: `arm-none-eabi-objdump -S`

このファイルは、C/C++のソースコードと、それに対応して生成されたアセンブリ命令を交互に配置（インターリーブ）したものです。

### 2.2 何が可能になったか (Capabilities)

このファイルの生成自動化により、以下の解析が即座に可能となりました。

#### A. コンパイラ最適化の検証
ソースコードが実際にどのような機械語に変換されたかを確認できます。
*   **インライン展開の確認**: 関数呼び出しが実際にインライン化されているか。
*   **ループ最適化**: ループが展開されているか、不要な処理が削除されているか。
*   **揮発性変数の扱い**: `volatile` 修飾子が正しく機能し、メモリアクセスが省略されていないか。

#### B. クラッシュアドレスの特定 (Crash Dump Analysis)
実行時に例外が発生し、プログラムカウンタ (PC) のアドレスしか判明していない場合でも、このファイルを参照することで、**「どのソースコード行の、どの命令でクラッシュしたか」**をピンポイントで特定できます。

#### C. 低レイヤー動作の理解
C++の抽象的な記述（クラス、テンプレートなど）が、実際のハードウェア上でどのようなコスト（命令数、メモリ操作）を伴うかを可視化できます。

### 2.3 活用例

**ソースコード:**
```c
gpio_init(LED_PIN);
```

**`blink.S.dis` での出力例:**
```asm
  gpio_init(LED_PIN);
100002de:       2019            movs    r0, #25
100002e0:       f000 f832       bl      10000348 <gpio_init>
```
このように、`gpio_init` 関数を呼び出すために、レジスタ `r0` に `25` (LED_PIN) をセットし、分岐命令 `bl` を実行していることが一目で分かります。

## 3. その他の解析ツール

### 3.1 セクションヘッダ情報の確認
`blink.elf` に対して `objdump -h` を実行することで、メモリレイアウト（各セクションの配置アドレスとサイズ）を確認できます。これは、スタックオーバーフローやメモリ不足の調査に役立ちます。
